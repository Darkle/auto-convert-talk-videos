import { spawn } from 'child_process'
import path from 'path'

import Maybe from 'folktale/maybe'

import { logger } from './logging.lsc'
import { noop } from './utils.lsc'
import { speed, dirToWatch as outputPath } from '../config.json'

// https://docs.microsoft.com/en-us/windows/desktop/CIMWin32Prov/setpriority-method-in-class-win32-process
belowNormalProcessPriorityId = 16384
ffmpegDefaultParams = [
  '-filter:v',
  `setpts=PTS/${ speed }`,
  '-filter:a',
  `atempo=${ speed }`,
  `-threads`,
  `1`,
]

convertVideo(srcFilePath:string, uniqueString:string):Promise ->
  return new Promise(resolve ->
    spawnedFFmpeg = spawn('ffmpeg', generateFFmpegParams(srcFilePath, uniqueString))
    spawnedFFmpeg.on('exit', code ->
      logger.info(`spawnedFFmpeg exited with code ${ code }`)
      resolve()
    )
    /*****
    * For some reason if you omit the stderr/stdout listeners sometimes ffmpeg
    * wont exit properly. ¯\_(ツ)_/¯
    */
    spawnedFFmpeg.stderr.on('data', noop)
    spawnedFFmpeg.stdout.on('data', noop)
    lowerFFmpegProcessPriority(spawnedFFmpeg.pid)
    Maybe.Nothing()
  )

/*****
* Based on https://github.com/soyuka/renice/blob/master/index.js
*/
lowerFFmpegProcessPriority(pid:number) ->
  spawn(
    'cmd.exe',
    [
      '/c',
      `wmic process where processid=${ pid } CALL setpriority ${ belowNormalProcessPriorityId }`,
    ]
  )
  Maybe.Nothing()

generateOutputFilePath(srcFilePath:string, uniqueString:string):string ->
  fileBaseName = path.basename(srcFilePath)
  fileExtension = path.extname(fileBaseName)
  outputFileName = fileBaseName.slice(0, fileBaseName.lastIndexOf(fileExtension)) +
    `-converted-${ uniqueString }` + fileExtension

  path.join(outputPath, outputFileName)

generateFFmpegParams(srcFilePath:string, uniqueString:string):Array<string> ->
  [
    '-i',
    srcFilePath,
    ...ffmpegDefaultParams,
    generateOutputFilePath(srcFilePath, uniqueString)
  ]

export {
  convertVideo
}
