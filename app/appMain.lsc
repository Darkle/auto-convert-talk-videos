import crypto from 'crypto'
import path from 'path'

import chokidar from 'chokidar'
import Maybe from 'folktale/maybe'
import delay from 'delay'
import del from 'del'

import { dirToWatch } from '../config.json'
import { convertVideo } from './ffmpeg.lsc'
import { logger } from './logging.lsc'

delayBeforeStartConverting = ISDEV ? 1000 : 5000
uniqueString = crypto.randomBytes(6).toString('hex')

watcher = chokidar.watch(dirToWatch, {
  ignored: /(^|[\/\\])\../, // ignore dotfiles
  persistent: true,
  awaitWriteFinish: {
    stabilityThreshold: ISDEV ? 2000 : 6000,
    pollInterval: 100,
  },
  ignoreInitial: true,
})

watcher
  .on('add', filePath ->
    if !shouldConvertVideo(filePath): return Maybe.Nothing()
    fileBaseName = path.basename(filePath)
    logger.info(`${ fileBaseName } has been added to folder. \nConversion will start in a moment...`)

    delay(delayBeforeStartConverting)
      .then(() -> convertVideo(filePath, uniqueString))
      .then(() -> logger.info(`finished converting ${ fileBaseName }`))
      .then(() -> del([filePath])) //move original file to trash
      .then(() -> logger.info('deleted original file'))
      .catch(logger.error)
  )

/*****
* The file will have .part if it's a jDownloader download, so we need to ignore that
* untill the download completes.
*
* We also need to check for a unique string, becuase once ffmpeg has finished converting,
* the new converted file shows up which triggers the watcher. So we need to ignore the new
* converted file as its already converted.
*/
shouldConvertVideo(filePath:string):boolean ->
  !filePath.endsWith('.part') && !filePath.includes(uniqueString)

process.on('unhandledRejection', logger.error)
process.on('uncaughtException', logger.error)
