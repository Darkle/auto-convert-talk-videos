{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./app/appMain.lsc","webpack:///./app/ffmpeg.lsc","webpack:///./app/logging.lsc","webpack:///./node_modules/@sindresorhus/df/index.js","webpack:///./node_modules/delay/index.js","webpack:///./node_modules/escape-string-applescript/index.js","webpack:///./node_modules/ffmkek/src/FFmkek.js","webpack:///./node_modules/ffmkek/src/Part.js","webpack:///./node_modules/fs-extra/lib/copy-sync/copy-file-sync.js","webpack:///./node_modules/fs-extra/lib/copy-sync/copy-sync.js","webpack:///./node_modules/fs-extra/lib/copy-sync/index.js","webpack:///./node_modules/fs-extra/lib/copy/copy.js","webpack:///./node_modules/fs-extra/lib/copy/index.js","webpack:///./node_modules/fs-extra/lib/copy/ncp.js","webpack:///./node_modules/fs-extra/lib/empty/index.js","webpack:///./node_modules/fs-extra/lib/ensure/file.js","webpack:///./node_modules/fs-extra/lib/ensure/index.js","webpack:///./node_modules/fs-extra/lib/ensure/link.js","webpack:///./node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack:///./node_modules/fs-extra/lib/ensure/symlink-type.js","webpack:///./node_modules/fs-extra/lib/ensure/symlink.js","webpack:///./node_modules/fs-extra/lib/index.js","webpack:///./node_modules/fs-extra/lib/json/index.js","webpack:///./node_modules/fs-extra/lib/json/jsonfile.js","webpack:///./node_modules/fs-extra/lib/json/output-json-sync.js","webpack:///./node_modules/fs-extra/lib/json/output-json.js","webpack:///./node_modules/fs-extra/lib/mkdirs/index.js","webpack:///./node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js","webpack:///./node_modules/fs-extra/lib/mkdirs/mkdirs.js","webpack:///./node_modules/fs-extra/lib/mkdirs/win32.js","webpack:///./node_modules/fs-extra/lib/move/index.js","webpack:///./node_modules/fs-extra/lib/output/index.js","webpack:///./node_modules/fs-extra/lib/remove/index.js","webpack:///./node_modules/fs-extra/lib/util/assign.js","webpack:///./node_modules/fs-extra/lib/util/utimes.js","webpack:///./node_modules/fs-extra/lib/walk/index.js","webpack:///./node_modules/jsonfile/index.js","webpack:///./node_modules/klaw/src/assign.js","webpack:///./node_modules/klaw/src/index.js","webpack:///./node_modules/mount-point/index.js","webpack:///./node_modules/mount-point/node_modules/@sindresorhus/df/index.js","webpack:///./node_modules/p-map/index.js","webpack:///./node_modules/run-applescript/index.js","webpack:///./node_modules/trash/index.js","webpack:///./node_modules/trash/lib/linux.js","webpack:///./node_modules/trash/lib/macos.js","webpack:///./node_modules/trash/lib/win.js","webpack:///./node_modules/user-home/index.js","webpack:///./node_modules/uuid/index.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng.js","webpack:///./node_modules/uuid/v1.js","webpack:///./node_modules/uuid/v4.js","webpack:///./node_modules/xdg-basedir/index.js","webpack:///./node_modules/xdg-trashdir/index.js","webpack:///external \"assert\"","webpack:///external \"child_process\"","webpack:///external \"chokidar\"","webpack:///external \"crypto\"","webpack:///external \"events\"","webpack:///external \"execa\"","webpack:///external \"folktale/maybe\"","webpack:///external \"fs\"","webpack:///external \"globby\"","webpack:///external \"graceful-fs\"","webpack:///external \"os\"","webpack:///external \"os-homedir\"","webpack:///external \"p-try\"","webpack:///external \"path\"","webpack:///external \"path-is-absolute\"","webpack:///external \"pify\"","webpack:///external \"pinkie-promise\"","webpack:///external \"rimraf\"","webpack:///external \"stream\"","webpack:///external \"util\"","webpack:///external \"winston\"","webpack:///external \"winston-daily-rotate-file\""],"names":["crypto","randomBytes","toString","chokidar","watch","dirToWatch","ignored","persistent","awaitWriteFinish","stabilityThreshold","pollInterval","ignoreInitial","watcher","on","shouldConvertVideo","filePath","Maybe","Nothing","logger","info","tenSecondsAsMilliseconds","then","uniqueString","log","catch","error","endsWith","includes","process","srcFilePath","FFmkek","addInput","addOption","speed","write","generateOutputFilePath","path","basename","extname","fileBaseName","slice","lastIndexOf","fileExtension","join","outputPath","outputFileName","convertVideo","winston","transports","DailyRotateFile","filename","dirname","datePattern","maxSize","maxFiles","fileTransport","push","Console","createLogger","level","format","prettyPrint"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;ACxBW;AACb,cAAc,mBAAO,CAAC,oBAAO;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,KAAK;AACrD,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,KAAK;AACjD;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;AClDa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,cAAc,KAAK;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,oDAAoD,WAAW;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Da;AACb;;;;;;;;;;;;ACDA,aAAa,mBAAO,CAAC,iDAAQ;AAC7B,OAAO,eAAe,GAAG,mBAAO,CAAC,sBAAQ;AACzC,OAAO,QAAQ,GAAG,mBAAO,CAAC,oCAAe;AACzC,OAAO,sBAAsB,GAAG,mBAAO,CAAC,sBAAQ;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,iBAAiB;AACxD,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvEA,SAAS,mBAAO,CAAC,gCAAa;;AAE9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtCA,SAAS,mBAAO,CAAC,gCAAa;AAC9B,WAAW,mBAAO,CAAC,kBAAM;AACzB,mBAAmB,mBAAO,CAAC,iFAAkB;AAC7C,YAAY,mBAAO,CAAC,8DAAW;;AAE/B;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,yEAAyE;AACxG;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/CA;AACA,YAAY,mBAAO,CAAC,uEAAa;AACjC;;;;;;;;;;;;ACFA,SAAS,mBAAO,CAAC,gCAAa;AAC9B,WAAW,mBAAO,CAAC,kBAAM;AACzB,UAAU,mBAAO,CAAC,sDAAO;AACzB,YAAY,mBAAO,CAAC,8DAAW;;AAE/B;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;;;;;AC3CA;AACA,QAAQ,mBAAO,CAAC,wDAAQ;AACxB;;;;;;;;;;;;ACFA;;AAEA,SAAS,mBAAO,CAAC,gCAAa;AAC9B,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,kEAAgB;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,oDAAoD,kBAAkB;;AAEtE;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClPA,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,8DAAW;AAC/B,aAAa,mBAAO,CAAC,8DAAW;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,gCAAa;AAC9B,YAAY,mBAAO,CAAC,8DAAW;;AAE/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1CA,WAAW,mBAAO,CAAC,0DAAQ;AAC3B,WAAW,mBAAO,CAAC,0DAAQ;AAC3B,cAAc,mBAAO,CAAC,gEAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,gCAAa;AAC9B,YAAY,mBAAO,CAAC,8DAAW;;AAE/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzDA,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA,wDAAwD,mBAAO,CAAC,0CAAkB;AAClF,SAAS,mBAAO,CAAC,gCAAa;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChGA,SAAS,mBAAO,CAAC,gCAAa;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,gCAAa;AAC9B,cAAc,mBAAO,CAAC,8DAAW;AAC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O,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;;AAEA;;AAEA,SAAS,mBAAO,CAAC,gCAAa;AAC9B,UAAU,mBAAO,CAAC,4DAAa;AAC/B,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,mBAAO,CAAC,8DAAW;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,yCAAyC,gBAAgB;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AChKA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,gCAAa;AAC9B,YAAY,mBAAO,CAAC,8DAAW;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClCA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;;AAEA;AACA,sEAAsE;AACtE;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;;ACbA,SAAS,mBAAO,CAAC,gCAAa;AAC9B,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;;AAErB,YAAY,IAAI;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpEA,WAAW,mBAAO,CAAC,8CAAM;;AAEzB;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA,QAAQ,mBAAO,CAAC,gCAAa;AAC7B,CAAC;AACD,QAAQ,mBAAO,CAAC,cAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpIA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;;;;;;;;;;;;ACfA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA,OAAO,mBAAO,CAAC,gCAAa;AAC5B,CAAC;AACD,OAAO,mBAAO,CAAC,cAAI;AACnB;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,mDAAU;;AAE/B;AACA;AACA,8BAA8B;AAC9B,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,mCAAmC;AACpF;AACA;AACA,uCAAuC,sBAAsB;;AAE7D;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxDa;AACb,SAAS,mBAAO,CAAC,2FAAkB;AACnC,WAAW,mBAAO,CAAC,kBAAM;AACzB,cAAc,mBAAO,CAAC,sCAAgB;;AAEtC;AACA;AACA;AACA,EAAE;AACF;;;;;;;;;;;;;ACTa;AACb,mBAAmB,mBAAO,CAAC,oCAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAC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","file":"appMain-compiled.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./app/appMain.lsc\");\n","import crypto from 'crypto'\r\n\r\nimport chokidar from 'chokidar'\r\nimport Maybe from 'folktale/maybe'\r\nimport delay from 'delay'\r\nimport trash from 'trash'\r\n\r\n// import { MaybeGetPath } from './utils.lsc'\r\nimport { dirToWatch } from '../config.json'\r\nimport { convertVideo } from './ffmpeg.lsc'\r\nimport { logger } from './logging.lsc'\r\n\r\ntenSecondsAsMilliseconds = 10000\r\nuniqueString = crypto.randomBytes(6).toString('hex')\r\n\r\nwatcher = chokidar.watch(dirToWatch, {\r\n  ignored: /(^|[\\/\\\\])\\../,\r\n  persistent: true,\r\n  awaitWriteFinish: {\r\n    stabilityThreshold: 6000,\r\n    pollInterval: 100,\r\n  },\r\n  ignoreInitial: true,\r\n})\r\n\r\nwatcher\r\n  .on('add', filePath ->\r\n    if !shouldConvertVideo(filePath): return Maybe.Nothing()\r\n    logger.info(`${ filePath } has been added to folder. Converting...`)\r\n    delay(tenSecondsAsMilliseconds)\r\n      .then(() -> convertVideo(filePath, uniqueString))\r\n      .then(() -> console.log('finished conversion'))\r\n      .then(() -> trash([filePath])) //move original file to trash\r\n      .catch(logger.error)\r\n  )\r\n\r\n/*****\r\n* The file will have .part if it's a jDownloader download, so we need to ignore that\r\n* untill the download completes.\r\n*\r\n* We also need to check for a unique string, becuase once ffmpeg has finished converting,\r\n* the new converted file shows up which triggers the watcher. So we need to ignore the new\r\n* converted file as its already converted.\r\n*/\r\nshouldConvertVideo(filePath:string):boolean ->\r\n  !filePath.endsWith('.part') && !filePath.includes(uniqueString)\r\n\r\nprocess.on('unhandledRejection', logger.error)\r\nprocess.on('uncaughtException', logger.error)\r\n","import path from 'path'\r\n\r\nimport FFmkek from 'ffmkek'\r\n\r\nimport { speed, dirToWatch as outputPath } from '../config.json'\r\n\r\nconvertVideo(srcFilePath:string, uniqueString:string):Promise ->\r\n  new FFmkek()\r\n    .addInput(srcFilePath)\r\n    .addOption('-filter:v', `setpts=PTS/${ speed }`)\r\n    .addOption('-filter:a', `atempo=${ speed }`)\r\n    .write(generateOutputFilePath(srcFilePath, uniqueString))\r\n\r\ngenerateOutputFilePath(srcFilePath:string, uniqueString:string):string ->\r\n  fileBaseName = path.basename(srcFilePath)\r\n  fileExtension = path.extname(fileBaseName)\r\n  outputFileName = fileBaseName.slice(0, fileBaseName.lastIndexOf(fileExtension)) +\r\n    `-converted-${ uniqueString }` + fileExtension\r\n\r\n  path.join(outputPath, outputFileName)\r\n\r\nexport {\r\n  convertVideo\r\n}\r\n","import winston from 'winston'\r\nimport 'winston-daily-rotate-file'\r\n\r\nfileTransport = new (winston.transports.DailyRotateFile)({\r\n  filename: 'auto-convert-talk-videos-%DATE%.log',\r\n  dirname: 'logs'\r\n  datePattern: 'YYYY-MM-DD-HH',\r\n  maxSize: '20m',\r\n  maxFiles: 5\r\n})\r\n\r\ntransports = [\r\n  fileTransport,\r\n]\r\n\r\nif ISDEV: transports.push(new winston.transports.Console())\r\n\r\nlogger = winston.createLogger({\r\n  level: 'info',\r\n  format: if ISDEV: winston.format.prettyPrint() else: winston.format.json()\r\n  transports\r\n})\r\n\r\nexport {\r\n  logger\r\n}\r\n","'use strict';\nconst execa = require('execa');\n\nconst run = args => execa('df', args).then(res =>\n\tres.stdout.trim().split('\\n').slice(1).map(x => {\n\t\tconst cl = x.split(/\\s+(?=[\\d\\/])/);\n\n\t\treturn {\n\t\t\tfilesystem: cl[0],\n\t\t\tsize: parseInt(cl[1], 10) * 1024,\n\t\t\tused: parseInt(cl[2], 10) * 1024,\n\t\t\tavailable: parseInt(cl[3], 10) * 1024,\n\t\t\tcapacity: parseInt(cl[4], 10) / 100,\n\t\t\tmountpoint: cl[5]\n\t\t};\n\t})\n);\n\nconst df = module.exports = () => run(['-kP']);\n\ndf.fs = name => {\n\tif (typeof name !== 'string') {\n\t\treturn Promise.reject(new Error('name required'));\n\t}\n\n\treturn run(['-kP']).then(data => {\n\t\tfor (const x of data) {\n\t\t\tif (x.filesystem === name) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`The specified filesystem \\`${name}\\` doesn't exist`);\n\t});\n};\n\ndf.file = file => {\n\tif (typeof file !== 'string') {\n\t\treturn Promise.reject(new Error('file required'));\n\t}\n\n\treturn run(['-kP', file])\n\t\t.then(data => data[0])\n\t\t.catch(err => {\n\t\t\tif (/No such file or directory/.test(err.message)) {\n\t\t\t\terr = new Error(`The specified file \\`${file}\\` doesn't exist`);\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t});\n};\n","'use strict';\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst createDelay = willResolve => (ms, {value, signal} = {}) => {\n\tif (signal && signal.aborted) {\n\t\treturn Promise.reject(createAbortError());\n\t}\n\n\tlet timeoutId;\n\tlet settle;\n\tlet rejectFn;\n\n\tconst signalListener = () => {\n\t\tclearTimeout(timeoutId);\n\t\trejectFn(createAbortError());\n\t};\n\n\tconst cleanup = () => {\n\t\tif (signal) {\n\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t}\n\t};\n\n\tconst delayPromise = new Promise((resolve, reject) => {\n\t\tsettle = () => {\n\t\t\tcleanup();\n\t\t\tif (willResolve) {\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\treject(value);\n\t\t\t}\n\t\t};\n\t\trejectFn = reject;\n\t\ttimeoutId = setTimeout(settle, ms);\n\t});\n\n\tif (signal) {\n\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t}\n\n\tdelayPromise.clear = () => {\n\t\tcleanup();\n\t\tif (timeoutId) {\n\t\t\tclearTimeout(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t}\n\t};\n\n\treturn delayPromise;\n};\n\nconst delay = createDelay(true);\ndelay.reject = createDelay(false);\nmodule.exports = delay;\nmodule.exports.default = delay;\n","'use strict';\nmodule.exports = x => typeof x === 'string' ? x.replace(/[\\\\\"]/g, '\\\\$&') : x;\n","const Part = require('./Part')\nconst { EventEmitter } = require('events')\nconst { spawn } = require('child_process')\nconst { Stream, PassThrough } = require('stream')\n\nclass FFmkek extends EventEmitter {\n  constructor(source) {\n    super()\n    this.path = 'ffmpeg'\n    \n    this.currentPart = new Part(this, 0)\n    this.parts = []\n\n    this.inputStream = null\n    this.outputStream = null\n\n    this.force = true\n\n    if (source) this.addInput(source)\n    this._setAliases()\n  }\n  \n  setPath(path) {\n    this.path = path\n    return this\n  }\n\n  addInput(input) {\n    return this._addPart(input, Part.INPUT)\n  }\n\n  setOutput(output) {\n    return this._addPart(output, Part.OUTPUT)\n  }\n\n  addOption(name, ...values) {\n    this.currentPart.addOption(name, ...values)\n    return this\n  }\n\n  setForce(flag) {\n    this.force = Boolean(flag)\n    return this\n  }\n\n  getArguments() {\n    const args = []\n    for (const part of this.parts) part.apply(args)\n    if (this.force) args.push('-y')\n    return args\n  }\n\n  run() {\n    if (!this._outputPart) this.setOutput(new PassThrough())\n    const proc = spawn(this.path, this.getArguments())\n    if (this.inputStream) this.inputStream.pipe(proc.stdin)\n    if (this.outputStream) proc.stdout.pipe(this.outputStream)\n\n    proc.stderr.on('data', data => this.emit('info', data.toString()))\n\n    return new Promise(resolve => {\n      if (this.outputStream) {\n        return resolve(this.outputStream)\n      }\n      proc.stderr.once('end', () => resolve(this._outputPart.name))\n    })\n  }\n\n  write(output) {\n    if (output) this.setOutput(output)\n    return this.run()\n  }\n\n  get _outputPart() {\n    return this.parts.find(part => part.type === Part.OUTPUT)\n  }\n\n  _addPart(io, type) {\n    if (io instanceof Stream) {\n      const isOutput = type === Part.OUTPUT\n      const prop = isOutput  ? 'outputStream' : 'inputStream'\n      if (this[prop]) {\n        throw new Error('only one input or output stream is supported')\n      }\n\n      this[prop] = io\n      this.currentPart.setName(`pipe:${isOutput ? 1 : 0}`)\n    } else {\n      this.currentPart.setName(io)\n    }\n\n    this.currentPart.setType(type)\n    this.parts.push(this.currentPart)\n    this.currentPart = new Part(this, this.parts.length)\n    return this\n  }\n\n  _setAliases() {\n    const proto = FFmkek.prototype\n    this._alias(proto.addInput, 'in', 'input')\n      ._alias(proto.setOutput, 'out', 'output', 'addOutput')\n      ._alias(proto.addOption, 'opt', 'option')\n      ._alias(proto.getArguments, 'args', 'arguments')\n      ._alias(proto.write, 'save')\n  }\n\n  _alias(method, ...aliases) {\n    for (const alias of aliases) this[alias] = method.bind(this)\n    return this\n  }\n\n  static get Part() {\n    return Part\n  }\n}\n\nmodule.exports = FFmkek\n","class Part {\n  constructor(command, id, name, type) {\n    this.command = command\n    this.id = id\n    this.name = name || null\n    this.type = type || null\n    this.options = new Map()\n\n    this.setName(name).setType(type)\n  }\n\n  addOption(name, ...values) {\n    if (!this.options.has(name)) this.options.set(name, [])\n    this.options.get(name).push(...values)\n    return this\n  }\n\n  setName(name) {\n    this.name = name\n    return this\n  }\n\n  setType(type) {\n    if (![Part.INPUT, Part.OUTPUT].includes(type)) type = Part.INPUT\n    this.type = type\n    return this\n  }\n\n  apply(args) {\n    for (const [name, values] of this.options) {\n      args.push(name)\n      if (values.length) args.push(values.join(', '))\n    }\n\n    if (this.type === Part.INPUT) args.push('-i')\n    args.push(this.name)\n    return args\n  }\n\n  isPipe() {\n    return this.name.startsWith('pipe')\n  }\n\n  isInput() {\n    return this.type === Part.INPUT\n  }\n\n  isOutput() {\n    return this.type === Part.OUTPUT\n  }\n\n  remove() {\n    this.command.parts.splice(this.id, 1)\n\n    if (this.isPipe()) {\n      if (this.isInput()) this.command.inputStream = null\n      else this.command.outputStream = null\n    }\n\n    return this\n  }\n\n  static get INPUT() {\n    return 'input'\n  }\n\n  static get OUTPUT() {\n    return 'output'\n  }\n}\n\nmodule.exports = Part\n","var fs = require('graceful-fs')\n\nvar BUF_LENGTH = 64 * 1024\nvar _buff = new Buffer(BUF_LENGTH)\n\nfunction copyFileSync (srcFile, destFile, options) {\n  var clobber = options.clobber\n  var preserveTimestamps = options.preserveTimestamps\n\n  if (fs.existsSync(destFile)) {\n    if (clobber) {\n      fs.chmodSync(destFile, parseInt('777', 8))\n      fs.unlinkSync(destFile)\n    } else {\n      throw Error('EEXIST')\n    }\n  }\n\n  var fdr = fs.openSync(srcFile, 'r')\n  var stat = fs.fstatSync(fdr)\n  var fdw = fs.openSync(destFile, 'w', stat.mode)\n  var bytesRead = 1\n  var pos = 0\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (preserveTimestamps) {\n    fs.futimesSync(fdw, stat.atime, stat.mtime)\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nmodule.exports = copyFileSync\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar copyFileSync = require('./copy-file-sync')\nvar mkdir = require('../mkdirs')\n\nfunction copySync (src, dest, options) {\n  if (typeof options === 'function' || options instanceof RegExp) {\n    options = {filter: options}\n  }\n\n  options = options || {}\n  options.recursive = !!options.recursive\n\n  // default to true for now\n  options.clobber = 'clobber' in options ? !!options.clobber : true\n  options.dereference = 'dereference' in options ? !!options.dereference : false\n  options.preserveTimestamps = 'preserveTimestamps' in options ? !!options.preserveTimestamps : false\n\n  options.filter = options.filter || function () { return true }\n\n  var stats = (options.recursive && !options.dereference) ? fs.lstatSync(src) : fs.statSync(src)\n  var destFolder = path.dirname(dest)\n  var destFolderExists = fs.existsSync(destFolder)\n  var performCopy = false\n\n  if (stats.isFile()) {\n    if (options.filter instanceof RegExp) performCopy = options.filter.test(src)\n    else if (typeof options.filter === 'function') performCopy = options.filter(src)\n\n    if (performCopy) {\n      if (!destFolderExists) mkdir.mkdirsSync(destFolder)\n      copyFileSync(src, dest, {clobber: options.clobber, preserveTimestamps: options.preserveTimestamps})\n    }\n  } else if (stats.isDirectory()) {\n    if (!fs.existsSync(dest)) mkdir.mkdirsSync(dest)\n    var contents = fs.readdirSync(src)\n    contents.forEach(function (content) {\n      var opts = options\n      opts.recursive = true\n      copySync(path.join(src, content), path.join(dest, content), opts)\n    })\n  } else if (options.recursive && stats.isSymbolicLink()) {\n    var srcPath = fs.readlinkSync(src)\n    fs.symlinkSync(srcPath, dest)\n  }\n}\n\nmodule.exports = copySync\n","module.exports = {\n  copySync: require('./copy-sync')\n}\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar ncp = require('./ncp')\nvar mkdir = require('../mkdirs')\n\nfunction copy (src, dest, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options\n    options = {}\n  } else if (typeof options === 'function' || options instanceof RegExp) {\n    options = {filter: options}\n  }\n  callback = callback || function () {}\n  options = options || {}\n\n  // don't allow src and dest to be the same\n  var basePath = process.cwd()\n  var currentPath = path.resolve(basePath, src)\n  var targetPath = path.resolve(basePath, dest)\n  if (currentPath === targetPath) return callback(new Error('Source and destination must not be the same.'))\n\n  fs.lstat(src, function (err, stats) {\n    if (err) return callback(err)\n\n    var dir = null\n    if (stats.isDirectory()) {\n      var parts = dest.split(path.sep)\n      parts.pop()\n      dir = parts.join(path.sep)\n    } else {\n      dir = path.dirname(dest)\n    }\n\n    fs.exists(dir, function (dirExists) {\n      if (dirExists) return ncp(src, dest, options, callback)\n      mkdir.mkdirs(dir, function (err) {\n        if (err) return callback(err)\n        ncp(src, dest, options, callback)\n      })\n    })\n  })\n}\n\nmodule.exports = copy\n","module.exports = {\n  copy: require('./copy')\n}\n","// imported from ncp (this is temporary, will rewrite)\n\nvar fs = require('graceful-fs')\nvar path = require('path')\nvar utimes = require('../util/utimes')\n\nfunction ncp (source, dest, options, callback) {\n  if (!callback) {\n    callback = options\n    options = {}\n  }\n\n  var basePath = process.cwd()\n  var currentPath = path.resolve(basePath, source)\n  var targetPath = path.resolve(basePath, dest)\n\n  var filter = options.filter\n  var transform = options.transform\n  var clobber = options.clobber !== false\n  var dereference = options.dereference\n  var preserveTimestamps = options.preserveTimestamps === true\n\n  var errs = null\n\n  var started = 0\n  var finished = 0\n  var running = 0\n  // this is pretty useless now that we're using graceful-fs\n  // consider removing\n  var limit = options.limit || 512\n\n  startCopy(currentPath)\n\n  function startCopy (source) {\n    started++\n    if (filter) {\n      if (filter instanceof RegExp) {\n        if (!filter.test(source)) {\n          return doneOne(true)\n        }\n      } else if (typeof filter === 'function') {\n        if (!filter(source)) {\n          return doneOne(true)\n        }\n      }\n    }\n    return getStats(source)\n  }\n\n  function getStats (source) {\n    var stat = dereference ? fs.stat : fs.lstat\n    if (running >= limit) {\n      return setImmediate(function () {\n        getStats(source)\n      })\n    }\n    running++\n    stat(source, function (err, stats) {\n      if (err) return onError(err)\n\n      // We need to get the mode from the stats object and preserve it.\n      var item = {\n        name: source,\n        mode: stats.mode,\n        mtime: stats.mtime, // modified time\n        atime: stats.atime, // access time\n        stats: stats // temporary\n      }\n\n      if (stats.isDirectory()) {\n        return onDir(item)\n      } else if (stats.isFile() || stats.isCharacterDevice() || stats.isBlockDevice()) {\n        return onFile(item)\n      } else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source)\n      }\n    })\n  }\n\n  function onFile (file) {\n    var target = file.name.replace(currentPath, targetPath)\n    isWritable(target, function (writable) {\n      if (writable) {\n        copyFile(file, target)\n      } else {\n        if (clobber) {\n          rmFile(target, function () {\n            copyFile(file, target)\n          })\n        } else {\n          doneOne()\n        }\n      }\n    })\n  }\n\n  function copyFile (file, target) {\n    var readStream = fs.createReadStream(file.name)\n    var writeStream = fs.createWriteStream(target, { mode: file.mode })\n\n    readStream.on('error', onError)\n    writeStream.on('error', onError)\n\n    if (transform) {\n      transform(readStream, writeStream, file)\n    } else {\n      writeStream.on('open', function () {\n        readStream.pipe(writeStream)\n      })\n    }\n\n    writeStream.once('finish', function () {\n      fs.chmod(target, file.mode, function (err) {\n        if (err) return onError(err)\n        if (preserveTimestamps) {\n          utimes.utimesMillis(target, file.atime, file.mtime, function (err) {\n            if (err) return onError(err)\n            return doneOne()\n          })\n        } else {\n          doneOne()\n        }\n      })\n    })\n  }\n\n  function rmFile (file, done) {\n    fs.unlink(file, function (err) {\n      if (err) return onError(err)\n      return done()\n    })\n  }\n\n  function onDir (dir) {\n    var target = dir.name.replace(currentPath, targetPath)\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target)\n      }\n      copyDir(dir.name)\n    })\n  }\n\n  function mkDir (dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) return onError(err)\n      // despite setting mode in fs.mkdir, doesn't seem to work\n      // so we set it here.\n      fs.chmod(target, dir.mode, function (err) {\n        if (err) return onError(err)\n        copyDir(dir.name)\n      })\n    })\n  }\n\n  function copyDir (dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) return onError(err)\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item))\n      })\n      return doneOne()\n    })\n  }\n\n  function onLink (link) {\n    var target = link.replace(currentPath, targetPath)\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) return onError(err)\n      checkLink(resolvedPath, target)\n    })\n  }\n\n  function checkLink (resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath)\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target)\n      }\n      fs.readlink(target, function (err, targetDest) {\n        if (err) return onError(err)\n\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest)\n        }\n        if (targetDest === resolvedPath) {\n          return doneOne()\n        }\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target)\n        })\n      })\n    })\n  }\n\n  function makeLink (linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) return onError(err)\n      return doneOne()\n    })\n  }\n\n  function isWritable (path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true)\n        return done(false)\n      }\n      return done(false)\n    })\n  }\n\n  function onError (err) {\n    if (options.stopOnError) {\n      return callback(err)\n    } else if (!errs && options.errs) {\n      errs = fs.createWriteStream(options.errs)\n    } else if (!errs) {\n      errs = []\n    }\n    if (typeof errs.write === 'undefined') {\n      errs.push(err)\n    } else {\n      errs.write(err.stack + '\\n\\n')\n    }\n    return doneOne()\n  }\n\n  function doneOne (skipped) {\n    if (!skipped) running--\n    finished++\n    if ((started === finished) && (running === 0)) {\n      if (callback !== undefined) {\n        return errs ? callback(errs) : callback(null)\n      }\n    }\n  }\n}\n\nmodule.exports = ncp\n","var fs = require('fs')\nvar path = require('path')\nvar mkdir = require('../mkdirs')\nvar remove = require('../remove')\n\nfunction emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, function (err, items) {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(function (item) {\n      return path.join(dir, item)\n    })\n\n    deleteItem()\n\n    function deleteItem () {\n      var item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, function (err) {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n}\n\nfunction emptyDirSync (dir) {\n  var items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(function (item) {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync: emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir: emptyDir,\n  emptydir: emptyDir\n}\n","var path = require('path')\nvar fs = require('graceful-fs')\nvar mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', function (err) {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.exists(file, function (fileExists) {\n    if (fileExists) return callback()\n    var dir = path.dirname(file)\n    fs.exists(dir, function (dirExists) {\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, function (err) {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  if (fs.existsSync(file)) return\n\n  var dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: createFile,\n  createFileSync: createFileSync,\n  // alias\n  ensureFile: createFile,\n  ensureFileSync: createFileSync\n}\n","var file = require('./file')\nvar link = require('./link')\nvar symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","var path = require('path')\nvar fs = require('graceful-fs')\nvar mkdir = require('../mkdirs')\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, function (err) {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  fs.exists(dstpath, function (destinationExists) {\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, function (err, stat) {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      var dir = path.dirname(dstpath)\n      fs.exists(dir, function (dirExists) {\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, function (err) {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath, callback) {\n  var destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  var dir = path.dirname(dstpath)\n  var dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: createLink,\n  createLinkSync: createLinkSync,\n  // alias\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync\n}\n","var path = require('path')\n// path.isAbsolute shim for Node.js 0.10 support\npath.isAbsolute = (path.isAbsolute) ? path.isAbsolute : require('path-is-absolute')\nvar fs = require('graceful-fs')\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, function (err, stat) {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    var dstdir = path.dirname(dstpath)\n    var relativeToDst = path.join(dstdir, srcpath)\n    return fs.exists(relativeToDst, function (exists) {\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, function (err, stat) {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  var exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    var dstdir = path.dirname(dstpath)\n    var relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  'symlinkPaths': symlinkPaths,\n  'symlinkPathsSync': symlinkPathsSync\n}\n","var fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, function (err, stats) {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  if (type) return type\n  try {\n    var stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType: symlinkType,\n  symlinkTypeSync: symlinkTypeSync\n}\n","var path = require('path')\nvar fs = require('graceful-fs')\nvar _mkdirs = require('../mkdirs')\nvar mkdirs = _mkdirs.mkdirs\nvar mkdirsSync = _mkdirs.mkdirsSync\n\nvar _symlinkPaths = require('./symlink-paths')\nvar symlinkPaths = _symlinkPaths.symlinkPaths\nvar symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nvar _symlinkType = require('./symlink-type')\nvar symlinkType = _symlinkType.symlinkType\nvar symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  fs.exists(dstpath, function (destinationExists) {\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, function (err, relative) {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, function (err, type) {\n        if (err) return callback(err)\n        var dir = path.dirname(dstpath)\n        fs.exists(dir, function (dirExists) {\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, function (err) {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  var destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  var relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  var dir = path.dirname(dstpath)\n  var exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: createSymlink,\n  createSymlinkSync: createSymlinkSync,\n  // alias\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n","var assign = require('./util/assign')\n\nvar fse = {}\nvar gfs = require('graceful-fs')\n\n// attach fs methods to fse\nObject.keys(gfs).forEach(function (key) {\n  fse[key] = gfs[key]\n})\n\nvar fs = fse\n\nassign(fs, require('./copy'))\nassign(fs, require('./copy-sync'))\nassign(fs, require('./mkdirs'))\nassign(fs, require('./remove'))\nassign(fs, require('./json'))\nassign(fs, require('./move'))\nassign(fs, require('./empty'))\nassign(fs, require('./ensure'))\nassign(fs, require('./output'))\nassign(fs, require('./walk'))\n\nmodule.exports = fs\n\n// maintain backwards compatibility for awhile\nvar jsonfile = {}\nObject.defineProperty(jsonfile, 'spaces', {\n  get: function () {\n    return fs.spaces // found in ./json\n  },\n  set: function (val) {\n    fs.spaces = val\n  }\n})\n\nmodule.exports.jsonfile = jsonfile // so users of fs-extra can modify jsonFile.spaces\n","var jsonFile = require('./jsonfile')\n\njsonFile.outputJsonSync = require('./output-json-sync')\njsonFile.outputJson = require('./output-json')\n// aliases\njsonFile.outputJSONSync = require('./output-json-sync')\njsonFile.outputJSON = require('./output-json')\n\nmodule.exports = jsonFile\n","var jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJSON: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  readJSONSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJSON: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync,\n  writeJSONSync: jsonFile.writeFileSync,\n  spaces: 2 // default in fs-extra\n}\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar jsonFile = require('./jsonfile')\nvar mkdir = require('../mkdirs')\n\nfunction outputJsonSync (file, data, options) {\n  var dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar jsonFile = require('./jsonfile')\nvar mkdir = require('../mkdirs')\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  var dir = path.dirname(file)\n\n  fs.exists(dir, function (itDoes) {\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, function (err) {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n","module.exports = {\n  mkdirs: require('./mkdirs'),\n  mkdirsSync: require('./mkdirs-sync'),\n  // alias\n  mkdirp: require('./mkdirs'),\n  mkdirpSync: require('./mkdirs-sync'),\n  ensureDir: require('./mkdirs'),\n  ensureDirSync: require('./mkdirs-sync')\n}\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar invalidWin32Path = require('./win32').invalidWin32Path\n\nvar o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  var mode = opts.mode\n  var xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    var errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    switch (err0.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) throw err0\n        made = mkdirsSync(path.dirname(p), opts, made)\n        mkdirsSync(p, opts, made)\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        var stat\n        try {\n          stat = xfs.statSync(p)\n        } catch (err1) {\n          throw err0\n        }\n        if (!stat.isDirectory()) throw err0\n        break\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar invalidWin32Path = require('./win32').invalidWin32Path\n\nvar o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    var errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  var mode = opts.mode\n  var xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, function (er) {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, function (er, made) {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, function (er2, stat) {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n","'use strict'\nvar path = require('path')\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  else return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nvar INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  var rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath: getRootPath,\n  invalidWin32Path: invalidWin32Path\n}\n","// most of this code was written by Andrew Kelley\n// licensed under the BSD license: see\n// https://github.com/andrewrk/node-mv/blob/master/package.json\n\n// this needs a cleanup\n\nvar fs = require('graceful-fs')\nvar ncp = require('../copy/ncp')\nvar path = require('path')\nvar rimraf = require('rimraf')\nvar mkdirp = require('../mkdirs').mkdirs\n\nfunction mv (source, dest, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  var shouldMkdirp = ('mkdirp' in options) ? options.mkdirp : true\n  var clobber = ('clobber' in options) ? options.clobber : false\n\n  var limit = options.limit || 16\n\n  if (shouldMkdirp) {\n    mkdirs()\n  } else {\n    doRename()\n  }\n\n  function mkdirs () {\n    mkdirp(path.dirname(dest), function (err) {\n      if (err) return callback(err)\n      doRename()\n    })\n  }\n\n  function doRename () {\n    if (clobber) {\n      fs.rename(source, dest, function (err) {\n        if (!err) return callback()\n\n        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {\n          rimraf(dest, function (err) {\n            if (err) return callback(err)\n            options.clobber = false // just clobbered it, no need to do it again\n            mv(source, dest, options, callback)\n          })\n          return\n        }\n\n        // weird Windows shit\n        if (err.code === 'EPERM') {\n          setTimeout(function () {\n            rimraf(dest, function (err) {\n              if (err) return callback(err)\n              options.clobber = false\n              mv(source, dest, options, callback)\n            })\n          }, 200)\n          return\n        }\n\n        if (err.code !== 'EXDEV') return callback(err)\n        moveAcrossDevice(source, dest, clobber, limit, callback)\n      })\n    } else {\n      fs.link(source, dest, function (err) {\n        if (err) {\n          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM') {\n            moveAcrossDevice(source, dest, clobber, limit, callback)\n            return\n          }\n          callback(err)\n          return\n        }\n        fs.unlink(source, callback)\n      })\n    }\n  }\n}\n\nfunction moveAcrossDevice (source, dest, clobber, limit, callback) {\n  fs.stat(source, function (err, stat) {\n    if (err) {\n      callback(err)\n      return\n    }\n\n    if (stat.isDirectory()) {\n      moveDirAcrossDevice(source, dest, clobber, limit, callback)\n    } else {\n      moveFileAcrossDevice(source, dest, clobber, limit, callback)\n    }\n  })\n}\n\nfunction moveFileAcrossDevice (source, dest, clobber, limit, callback) {\n  var outFlags = clobber ? 'w' : 'wx'\n  var ins = fs.createReadStream(source)\n  var outs = fs.createWriteStream(dest, {flags: outFlags})\n\n  ins.on('error', function (err) {\n    ins.destroy()\n    outs.destroy()\n    outs.removeListener('close', onClose)\n\n    // may want to create a directory but `out` line above\n    // creates an empty file for us: See #108\n    // don't care about error here\n    fs.unlink(dest, function () {\n      // note: `err` here is from the input stream errror\n      if (err.code === 'EISDIR' || err.code === 'EPERM') {\n        moveDirAcrossDevice(source, dest, clobber, limit, callback)\n      } else {\n        callback(err)\n      }\n    })\n  })\n\n  outs.on('error', function (err) {\n    ins.destroy()\n    outs.destroy()\n    outs.removeListener('close', onClose)\n    callback(err)\n  })\n\n  outs.once('close', onClose)\n  ins.pipe(outs)\n\n  function onClose () {\n    fs.unlink(source, callback)\n  }\n}\n\nfunction moveDirAcrossDevice (source, dest, clobber, limit, callback) {\n  var options = {\n    stopOnErr: true,\n    clobber: false,\n    limit: limit\n  }\n\n  function startNcp () {\n    ncp(source, dest, options, function (errList) {\n      if (errList) return callback(errList[0])\n      rimraf(source, callback)\n    })\n  }\n\n  if (clobber) {\n    rimraf(dest, function (err) {\n      if (err) return callback(err)\n      startNcp()\n    })\n  } else {\n    startNcp()\n  }\n}\n\nmodule.exports = {\n  move: mv\n}\n","var path = require('path')\nvar fs = require('graceful-fs')\nvar mkdir = require('../mkdirs')\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  var dir = path.dirname(file)\n  fs.exists(dir, function (itDoes) {\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, function (err) {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, data, encoding) {\n  var dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync.apply(fs, arguments)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync.apply(fs, arguments)\n}\n\nmodule.exports = {\n  outputFile: outputFile,\n  outputFileSync: outputFileSync\n}\n","var rimraf = require('rimraf')\n\nfunction removeSync (dir) {\n  return rimraf.sync(dir)\n}\n\nfunction remove (dir, callback) {\n  return callback ? rimraf(dir, callback) : rimraf(dir, function () {})\n}\n\nmodule.exports = {\n  remove: remove,\n  removeSync: removeSync\n}\n","// simple mutable assign\nfunction assign () {\n  var args = [].slice.call(arguments).filter(function (i) { return i })\n  var dest = args.shift()\n  args.forEach(function (src) {\n    Object.keys(src).forEach(function (key) {\n      dest[key] = src[key]\n    })\n  })\n\n  return dest\n}\n\nmodule.exports = assign\n","var fs = require('graceful-fs')\nvar path = require('path')\nvar os = require('os')\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  var tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  var d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  var fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  var tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  var d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', function (err) {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', function (err, fd) {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, function (err) {\n        if (err) return callback(err)\n        fs.close(fd, function (err) {\n          if (err) return callback(err)\n          fs.stat(tmpfile, function (err, stats) {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', function (err, fd) {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, function (err) {\n      if (err) return callback(err)\n      fs.close(fd, callback)\n    })\n  })\n}\n\nmodule.exports = {\n  hasMillisRes: hasMillisRes,\n  hasMillisResSync: hasMillisResSync,\n  timeRemoveMillis: timeRemoveMillis,\n  utimesMillis: utimesMillis\n}\n","var klaw = require('klaw')\n\nmodule.exports = {\n  walk: klaw\n}\n","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  var content = fs.readFileSync(file, options)\n  content = stripBom(content)\n\n  try {\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = ''\n  try {\n    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\\n'\n  } catch (err) {\n    if (callback) return callback(err, null)\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = JSON.stringify(obj, options.replacer, spaces) + '\\n'\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  spaces: null,\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n","// simple mutable assign (extracted from fs-extra)\n// I really like object-assign package, but I wanted a lean package with zero deps\nfunction _assign () {\n  var args = [].slice.call(arguments).filter(function (i) { return i })\n  var dest = args.shift()\n  args.forEach(function (src) {\n    Object.keys(src).forEach(function (key) {\n      dest[key] = src[key]\n    })\n  })\n\n  return dest\n}\n\n// thank you baby Jesus for Node v4 and Object.assign\nmodule.exports = Object.assign || _assign\n","var assert = require('assert')\nvar fs\ntry {\n  fs = require('graceful-fs')\n} catch (e) {\n  fs = require('fs')\n}\nvar path = require('path')\nvar Readable = require('stream').Readable\nvar util = require('util')\nvar assign = require('./assign')\n\nfunction Walker (dir, options) {\n  assert.strictEqual(typeof dir, 'string', '`dir` parameter should be of type string. Got type: ' + typeof dir)\n  var defaultStreamOptions = { objectMode: true }\n  var defaultOpts = { queueMethod: 'shift', pathSorter: undefined, filter: undefined }\n  options = assign(defaultOpts, options, defaultStreamOptions)\n\n  Readable.call(this, options)\n  this.root = path.resolve(dir)\n  this.paths = [this.root]\n  this.options = options\n  this.fs = options.fs || fs // mock-fs\n}\nutil.inherits(Walker, Readable)\n\nWalker.prototype._read = function () {\n  if (this.paths.length === 0) return this.push(null)\n  var self = this\n  var pathItem = this.paths[this.options.queueMethod]()\n\n  self.fs.lstat(pathItem, function (err, stats) {\n    var item = { path: pathItem, stats: stats }\n    if (err) return self.emit('error', err, item)\n    if (!stats.isDirectory()) return self.push(item)\n\n    self.fs.readdir(pathItem, function (err, pathItems) {\n      if (err) {\n        self.push(item)\n        return self.emit('error', err, item)\n      }\n\n      pathItems = pathItems.map(function (part) { return path.join(pathItem, part) })\n      if (self.options.filter) pathItems = pathItems.filter(self.options.filter)\n      if (self.options.pathSorter) pathItems.sort(self.options.pathSorter)\n      pathItems.forEach(function (pi) { self.paths.push(pi) })\n\n      self.push(item)\n    })\n  })\n}\n\nfunction walk (root, options) {\n  return new Walker(root, options)\n}\n\nmodule.exports = walk\n","'use strict';\nvar df = require('@sindresorhus/df');\nvar pify = require('pify');\nvar Promise = require('pinkie-promise');\n\nmodule.exports = function (file) {\n\treturn pify(df.file, Promise)(file).then(function (data) {\n\t\treturn data.mountpoint;\n\t});\n};\n","'use strict';\nvar childProcess = require('child_process');\n\nfunction run(args, cb) {\n\tchildProcess.execFile('df', args, function (err, stdout) {\n\t\tif (err) {\n\t\t\tcb(err);\n\t\t\treturn;\n\t\t}\n\n\t\tcb(null, stdout.trim().split('\\n').slice(1).map(function (el) {\n\t\t\tvar cl = el.split(/\\s+(?=[\\d\\/])/);\n\n\t\t\treturn {\n\t\t\t\tfilesystem: cl[0],\n\t\t\t\tsize: parseInt(cl[1], 10) * 1024,\n\t\t\t\tused: parseInt(cl[2], 10) * 1024,\n\t\t\t\tavailable: parseInt(cl[3], 10) * 1024,\n\t\t\t\tcapacity: parseInt(cl[4], 10) / 100,\n\t\t\t\tmountpoint: cl[5]\n\t\t\t};\n\t\t}));\n\t});\n};\n\nvar df = module.exports = function (cb) {\n\trun(['-kP'], cb);\n};\n\ndf.fs = function (name, cb) {\n\tif (typeof name !== 'string') {\n\t\tthrow new Error('name required');\n\t}\n\n\trun(['-kP'], function (err, data) {\n\t\tif (err) {\n\t\t\tcb(err);\n\t\t\treturn;\n\t\t}\n\n\t\tvar ret;\n\n\t\tdata.forEach(function (el) {\n\t\t\tif (el.filesystem === name) {\n\t\t\t\tret = el;\n\t\t\t}\n\t\t});\n\n\t\tcb(null, ret);\n\t});\n};\n\ndf.file = function (file, cb) {\n\tif (typeof file !== 'string') {\n\t\tthrow new Error('file required');\n\t}\n\n\trun(['-kP', file], function (err, data) {\n\t\tif (err) {\n\t\t\tcb(err);\n\t\t\treturn;\n\t\t}\n\n\t\tcb(null, data[0]);\n\t});\n};\n","'use strict';\nmodule.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity\n\t}, opts);\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tconst concurrency = opts.concurrency;\n\n\tif (!(typeof concurrency === 'number' && concurrency >= 1)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tconst ret = [];\n\tconst iterator = iterable[Symbol.iterator]();\n\tlet isRejected = false;\n\tlet iterableDone = false;\n\tlet resolvingCount = 0;\n\tlet currentIdx = 0;\n\n\tconst next = () => {\n\t\tif (isRejected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextItem = iterator.next();\n\t\tconst i = currentIdx;\n\t\tcurrentIdx++;\n\n\t\tif (nextItem.done) {\n\t\t\titerableDone = true;\n\n\t\t\tif (resolvingCount === 0) {\n\t\t\t\tresolve(ret);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresolvingCount++;\n\n\t\tPromise.resolve(nextItem.value)\n\t\t\t.then(el => mapper(el, i))\n\t\t\t.then(\n\t\t\t\tval => {\n\t\t\t\t\tret[i] = val;\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\tisRejected = true;\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t);\n\t};\n\n\tfor (let i = 0; i < concurrency; i++) {\n\t\tnext();\n\n\t\tif (iterableDone) {\n\t\t\tbreak;\n\t\t}\n\t}\n});\n","'use strict';\nconst execa = require('execa');\n\nmodule.exports = script => {\n\tif (process.platform !== 'darwin') {\n\t\treturn Promise.reject(new Error('macOS only'));\n\t}\n\n\treturn execa.stdout('osascript', ['-e', script]);\n};\n\nmodule.exports.sync = script => {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\treturn execa.sync('osascript', ['-e', script]).stdout;\n};\n","'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst globby = require('globby');\nconst pTry = require('p-try');\nconst macos = require('./lib/macos');\nconst linux = require('./lib/linux');\nconst win = require('./lib/win');\n\nmodule.exports = (iterable, opts) => pTry(() => {\n\titerable = Array.from(typeof iterable === 'string' ? [iterable] : iterable).map(String);\n\topts = Object.assign({glob: true}, opts);\n\n\tconst paths = (opts.glob === false ? iterable : globby.sync(iterable, {\n\t\texpandDirectories: false,\n\t\tnodir: false,\n\t\tnonull: true\n\t}))\n\t\t.map(x => path.resolve(x))\n\t\t.filter(x => {\n\t\t\ttry {\n\t\t\t\treturn fs.lstatSync(x);\n\t\t\t} catch (err) {\n\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t});\n\n\tif (paths.length === 0) {\n\t\treturn;\n\t}\n\n\tswitch (process.platform) {\n\t\tcase 'darwin': return macos(paths);\n\t\tcase 'win32': return win(paths);\n\t\tdefault: return linux(paths);\n\t}\n});\n","'use strict';\nconst os = require('os');\nconst path = require('path');\nconst fsExtra = require('fs-extra');\nconst pify = require('pify');\nconst uuid = require('uuid');\nconst xdgTrashdir = require('xdg-trashdir');\nconst pMap = require('p-map');\n\nconst fs = pify(fsExtra);\n\nfunction trash(src) {\n\treturn xdgTrashdir(src).then(dir => {\n\t\tconst name = uuid.v4();\n\t\tconst dest = path.join(dir, 'files', name);\n\t\tconst info = path.join(dir, 'info', `${name}.trashinfo`);\n\t\tconst msg = `\n[Trash Info]\nPath=${src.replace(/\\s/g, '%20')}\nDeletionDate=${(new Date()).toISOString()}\n\t\t`.trim();\n\n\t\treturn Promise.all([\n\t\t\tfs.move(src, dest, {mkdirp: true}),\n\t\t\tfs.outputFile(info, msg)\n\t\t]).then(() => ({\n\t\t\tpath: dest,\n\t\t\tinfo\n\t\t}));\n\t});\n}\n\nmodule.exports = paths => pMap(paths, trash, {concurrency: os.cpus().length});\n","'use strict';\nconst os = require('os');\nconst path = require('path');\nconst execFile = require('child_process').execFile;\nconst escapeStringApplescript = require('escape-string-applescript');\nconst runApplescript = require('run-applescript');\nconst pify = require('pify');\n\nconst olderThanMountainLion = Number(os.release().split('.')[0]) < 12;\n\n// Binary source: https://github.com/sindresorhus/macos-trash\nconst bin = path.join(__dirname, 'macos-trash');\n\nfunction legacy(paths) {\n\tconst pathStr = paths.map(x => `\"${escapeStringApplescript(x)}\"`).join(',');\n\tconst script = `\nset deleteList to {}\nrepeat with currentPath in {${pathStr}}\nset end of deleteList to POSIX file currentPath\nend repeat\ntell app \"Finder\" to delete deleteList\n\t`.trim();\n\n\treturn runApplescript(script).catch(err => {\n\t\tif (/10010/.test(err.message)) {\n\t\t\terr = new Error('Item doesn\\'t exist');\n\t\t}\n\n\t\tthrow err;\n\t});\n}\n\nmodule.exports = paths => {\n\tif (olderThanMountainLion) {\n\t\treturn legacy(paths);\n\t}\n\n\treturn pify(execFile)(bin, paths);\n};\n","'use strict';\nconst path = require('path');\nconst execFile = require('child_process').execFile;\nconst pify = require('pify');\n\n// Binary source: https://github.com/sindresorhus/recycle-bin\nconst bin = path.join(__dirname, 'win-trash.exe');\n\nmodule.exports = paths => pify(execFile)(bin, paths);\n","'use strict';\nmodule.exports = require('os-homedir')();\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","'use strict';\nvar path = require('path');\nvar osHomedir = require('os-homedir');\nvar home = osHomedir();\nvar env = process.env;\n\nexports.data = env.XDG_DATA_HOME ||\n\t(home ? path.join(home, '.local', 'share') : null);\n\nexports.config = env.XDG_CONFIG_HOME ||\n\t(home ? path.join(home, '.config') : null);\n\nexports.cache = env.XDG_CACHE_HOME || (home ? path.join(home, '.cache') : null);\n\nexports.runtime = env.XDG_RUNTIME_DIR || null;\n\nexports.dataDirs = (env.XDG_DATA_DIRS || '/usr/local/share/:/usr/share/').split(':');\n\nif (exports.data) {\n\texports.dataDirs.unshift(exports.data);\n}\n\nexports.configDirs = (env.XDG_CONFIG_DIRS || '/etc/xdg').split(':');\n\nif (exports.config) {\n\texports.configDirs.unshift(exports.config);\n}\n","'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst df = require('@sindresorhus/df');\nconst mountPoint = require('mount-point');\nconst userHome = require('user-home');\nconst xdgBasedir = require('xdg-basedir');\nconst pify = require('pify');\n\nconst check = file => {\n\tconst topuid = `${file}-${process.getuid()}`;\n\tconst stickyBitMode = 17407;\n\n\treturn pify(fs.lstat)(file)\n\t\t.then(stats => {\n\t\t\tif (stats.isSymbolicLink() || stats.mode !== stickyBitMode) {\n\t\t\t\treturn topuid;\n\t\t\t}\n\n\t\t\treturn path.join(file, String(process.getuid()));\n\t\t})\n\t\t.catch(err => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn topuid;\n\t\t\t}\n\n\t\t\treturn path.join(xdgBasedir.data, 'Trash');\n\t\t});\n};\n\nmodule.exports = file => {\n\tif (process.platform !== 'linux') {\n\t\treturn Promise.reject(new Error('Only Linux systems are supported'));\n\t}\n\n\tif (!file) {\n\t\treturn Promise.resolve(path.join(xdgBasedir.data, 'Trash'));\n\t}\n\n\treturn Promise.all([\n\t\tmountPoint(userHome),\n\t\t// Ignore errors in case `file` is a dangling symlink\n\t\tmountPoint(file).catch(() => {})\n\t]).then(mountPoints => {\n\t\tconst homeMountPoint = mountPoints[0];\n\t\tconst fileMountPoint = mountPoints[1];\n\t\tif (!fileMountPoint || fileMountPoint === homeMountPoint) {\n\t\t\treturn path.join(xdgBasedir.data, 'Trash');\n\t\t}\n\n\t\treturn check(path.join(fileMountPoint, '.Trash'));\n\t});\n};\n\nmodule.exports.all = () => {\n\tif (process.platform !== 'linux') {\n\t\treturn Promise.reject(new Error('Only Linux systems are supported'));\n\t}\n\n\treturn df().then(list => Promise.all(list.map(file => {\n\t\tif (file.mountpoint === '/') {\n\t\t\treturn path.join(xdgBasedir.data, 'Trash');\n\t\t}\n\n\t\treturn check(path.join(file.mountpoint, '.Trash'));\n\t})));\n};\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"chokidar\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"execa\");","module.exports = require(\"folktale/maybe\");","module.exports = require(\"fs\");","module.exports = require(\"globby\");","module.exports = require(\"graceful-fs\");","module.exports = require(\"os\");","module.exports = require(\"os-homedir\");","module.exports = require(\"p-try\");","module.exports = require(\"path\");","module.exports = require(\"path-is-absolute\");","module.exports = require(\"pify\");","module.exports = require(\"pinkie-promise\");","module.exports = require(\"rimraf\");","module.exports = require(\"stream\");","module.exports = require(\"util\");","module.exports = require(\"winston\");","module.exports = require(\"winston-daily-rotate-file\");"],"sourceRoot":""}